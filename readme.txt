Lesson_4
Практическим заданием будет каталог товаров, состоящий из двух страниц:
главной со списком товаров и кнопкой их добавления;
и страницы добавления товара.

### Приложение должно функционировать в синхронном режиме: пользователь нажимает кнопку «Добавить товар», переходит на
предназначенную для этого страницу, указывает в форме необходимые данные и нажимает «Сохранить». После этого он
перенаправляется на главную страницу, где в табличной форме отображается список всех товаров. Проект должен быть
привязан к базе данных SQLite3 (БД по умолчанию) и иметь минимальную сложность стилевого оформления.

## При работе над проектом:
+### 1. Создать виртуальное окружение проекта, под которым установить необходимый инструментарий (файл requirements.txt).

+### 2. Под виртуальным окружением создать Django-проект и одно приложение, настроить файл settings.py, выполнить
базовые миграции. Запустить Django-сервер для проверки работоспособности проекта.

+### 3. В каталоге приложения создать модель, которая должна хранить информацию о поступивших товарах: название,
дату поступления, цену, единицу измерения, имя поставщика. Выполнить миграции.

+### 4. Проверить правильность созданной модели, зарегистрировав ее в админке приложения.

+### 5. На основе модели добавить класс формы указания данных о товаре. Использовать наследование от forms.ModelForm.

+### 6. Настроить файл urls.py внутреннего каталога проекта. Он должен содержать два шаблона url-адресов: привязку к
url-адресу админки проекта (будет в файле по умолчанию после создания проекта) и привязку к набору шаблонов url-адресов
созданного приложения (оператор include).

+### 7. Создать и настроить файл привязок urls.py для приложения. В этом файле создать две привязки: к url-адресу
главной страницы проекта и к странице добавления товара. Для каждой из привязок указать функцию-контроллер и название.
Функции-контроллеры должны отвечать за загрузку списка товаров на главной странице и добавление товара на второй
странице.

+### 8. В файле views.py каталога проекта реализовать два контроллера в формате функций. Первый должен извлекать все
записи из модели с каталогом товаром и передавать переменную со списком товаров в контекст шаблона (html-страница со
списком товаров). Во втором контроллере должен создаваться объект формы для ввода данных о товаре и выполняться
рендеринг шаблона страницы добавления товара. В контекст шаблона необходимо передавать объект формы.

+### 9. В корне проекта создать директорию templates с двумя стандартными шаблонами: базовым (base.html) и шаблоном
формы (form.html). Базовый шаблон будет соответствовать каркасу главной страницы. В нем необходимо реализовать один
динамически обновляемый блок — например, {% block content %}{% endblock %}. Он будет содержать таблицу со списком
товаров, которая динамически подгружается из шаблона-наследника (html-страница со списком товаров). В файле base.html
необходимо подключить статику и указать ссылку на CSS-файл со стилизацией проекта. Можно воспользоваться файлом
bootstrap.min.css (его нужно скачать и поместить в каталог .static/css).

+### 10. В шаблоне формы form.html, используя теги шаблонов, реализовать разметку формы. При этом использовать
переменную контекста шаблона, содержащую объект формы, — например, form. К надписям полей обращаться по field.label,
к самим полям — field.

+### 11. В каталоге приложения создать директорию templates с двумя шаблонами: шаблоном html-страницы со списком
товаров (goods_list.html) и html-страницы (формы) их добавления (good_create.html). В первом шаблоне необходимо
указать шаблон-родитель base.html, кнопку добавления товара и разметить html-таблицу. Каждая из ее строк (кроме
той, что с заголовками) должна формироваться при переборе содержимого переменной со списком товаров — мы ее
предварительно передали в контекст данного шаблона из соответствующего контроллера. Для каждого из значений переменной
(фактически — это запись базы данных), полученного в цикле, необходимо обратиться к нужному полю и вывести его в
соответствующей ячейке. К кнопке привязать ссылку на страницу добавления товара. Для этого использовать имя нужного
шаблона url-адреса файла urls.py приложения.

+### 12. В шаблоне good_create.html создать html-тег form. В него поместить тег include, добавляющий html-разметку
формы (form.html) и кнопку добавления товара. Для тега form необходимо определить два атрибута: method со значением
post и enctype со значением multipart/form-data.

-------------------------------------------------------------------------------------------------------------------
Lesson 5

Продолжим работать над каталогом товаров. На данный момент приложение действует в синхронном режиме, т.е. пользователь
нажимает кнопку добавления, после чего выполняется переход на соответствующую страницу.
Усовершенствуем работу проекта: сделаем его более похожим на десктопное приложение — без всяких перезагрузок страницы.
Форма должна загружаться, как модальное окно, как бы «поверх» содержимого главной страницы. После этого пользователь
может указать данные нового товара и сохранить его в базе. При этом модальное окно формы должно закрываться,
а изменения, т.е. строка с добавленным товаром, должна отобразиться в таблице на главной странице. Таким образом мы
реализуем асинхронную работу приложения. Для этого необходимо использовать знания языка программирования JavaScript и
библиотеки jQuery. Разобьем выполнение задания на несколько этапов:

1. Доработка шаблонов

goods_list.html
В первую очередь необходимо внести изменения в шаблон goods_list.html. Создадим пустую структуру вложенных блочных
элементов div (три элемента). Ее содержимое будет динамически изменяться при нажатии кнопки добавления товара, т.е.
будет загружаться модальное окно формы добавления товара. Данную структуру можно реализовать следующим образом:
<div class="modal fade" id="modal-good">
<div class="modal-dialog">
<div class="modal-content">

  </div>
</div>

</div>
В данном случае первый блочный элемент div с идентификатором modal-good соответствует модальному окну формы добавления
товара. Второй div позволяет определить стилизацию компактного окна, а третий будет содержать html-код самой формы.
Он будет динамически передаваться в этот div, и пользователь увидит на экране подгружаемую форму. Приведенный код
необходимо разместить в конце шаблона goods_list.html.
Далее в этом же шаблоне goods_list.html следует изменить разметку кнопки добавления товара: убрать из тега button
тег ссылки <a> и заменить его простым тегом строки span c названием кнопки. Тегу button назначить два атрибута:
class (необходим для получения доступа к элементу из файла-скрипта) и data-url (позволяет идентифицировать страницу,
генерируемую посредством jQuery).
Разметка кнопки при этом может принять такой вид:
<button type="button" class="js-create-good" data-url="{% url 'good_create' %}">
Следующее, что необходимо сделать с файлом goods_list.html, — подключить скрипт на языке JavaScript, который позволит
силами библиотеки jQuery реализовать асинхронное взаимодействие с сервером. При этом тег script надо поместить в
соответствующий тег шаблона {% block javascript %}{% endblock %}.
Поскольку динамически у нас должна обновляться не вся главная html-страница, а лишь табличная часть со списком товаров,
создадим дополнительный шаблон partial_goods_list.html. В него поместим шаблонный тег цикла, отвечающего за
формирование таблицы с данными. При этом в файле шаблона goods_list.html выполним импорт файла нового шаблона
partial_goods_list.html.
base.html
В этом файле необходимо добавить подключение библиотеки jQuery. Для локального подключения следует скачать и поместить
в директорию static/js файл с кодом библиотеки — например, jquery-3.3.1.min.js. В эту же директорию следует добавить
файл bootstrap.min.js, который позволит упростить стилизацию элементов страницы.
good_create.html
Это шаблон, в котором находится разметка формы добавления товара. Его следует модифицировать, указав в атрибуте action
тега form имя url-шаблона адреса, при переходе на который запускается контроллер записи в модель введенных данных.
В нашем случае это шаблон good_create.html.
Также в данный шаблон необходимо поместить тег импорта разметки самой формы form.html в блочный элемент и добавить
две кнопки: сохранения данных в форме и ее закрытия.
Пример кода до изменений:
<form method="post" enctype="multipart/form-data">
{% include "form.html" %}

<div class="submit-button"><input type="submit"
value="Добавить"></div>
</form>

И после изменений:
<form method="post" action="{% url 'good_create' %}" class="js-good-create-form">
{% csrf_token %}
<div class="modal-body">
{% include "form.html" %}
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
<button type="submit" class="btn btn-primary">Create good</button>
</div>
</form>
Атрибут data-dismiss со значением modal позволяет реализовать закрытие формы по нажатию данной кнопки.
form.html
В шаблон формы необходимо выполнить загрузку инструментов пакета django-widget-tweaks:
{% load widget_tweaks %}


2. Доработка контроллеров

Необходимо доработать один из двух наших контроллеров и написать третий. С первым — good_list — все в порядке, а во
втором контроллере необходимо реализовать только проверку типа запроса: POST или GET. При этом также должен
генерироваться экземпляр формы. Возвращать этот контроллер должен вызов дополнительного контроллера-функции
save_good_form с со следующими параметрами: объект запроса, объект формы, шаблон. Поскольку данный контроллер
должен «открыть» форму добавления товара, в качестве шаблона следует передавать good_create.html.
Контроллер save_good_form используется для проверки валидности и формирования словаря data, в котором мы будем
указывать, является ли форма валидной, а также передавать преобразованный в строку шаблон и контекст
(метод render_to_string). Данный контроллер будет возвращать ответ в формате JSON. Это позволит работать с формой и
контекстом из файла скрипта средствами библиотеки jQuery, то есть асинхронно делать форму и передавать данные на
сторону сервера.

Пример того, как может быть реализован дополнительный контроллер save_good_form:
def save_good_form(request, form, template_name):
data = dict()
if request.method == 'POST':
if form.is_valid():
form.save()
data['form_is_valid'] = True
goods = Good_Item.objects.all()
data['html_good_list'] = render_to_string('good_list.html', {
'goods': goods
})
else:
data['form_is_valid'] = False
context = {'form': form}
data['html_form'] = render_to_string(template_name, context, request=request)
return JsonResponse(data)


3. Написание скрипта

Этот скрипт должен обрабатывать переданные в формате JSON данные: обращаться с помощью селекторов к элементам
веб-страницы и осуществлять манипуляции над ними. Подразумевается динамическое обновление содержимого главной
страницы: подгрузка шаблона формы, а также асинхронное (без перезагрузки главной страницы) сохранение данных в модель.
Для этого в файле сценария должны быть реализованы две функции. Первая отвечает за загрузку формы, вторая — за
сохранение введенных в форму данных. Для запуска первой функции необходимо выполнить ее привязку к событию нажатия
на кнопку добавления товара. Для запуска второй привязка должна быть выполнена к событию отправки формы. И функции,
и инструкции их вызова должны быть сохранены в функции-обертке $(function(){....программный код….});, чтобы решить
всю задачу средствами библиотеки jQuery.
